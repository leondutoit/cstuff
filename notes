
printf

escape codes

\n newline
\t tab
\v vertical tab
\f new page
\b backspace
\r carriage return

format sequences %

i, d int
c, char
f, e, E, g, G floating points and scientific
h short int, unsigned short int
ld long int, unsigned long int
l wide string
L long double
s string

valgrind

valgrind --track-origins=yes ./ex4

conditional jump or move depends on uninitialised value


in char - difference betweeen single and double quotes

string is an array of chars

0 - falsy
>0 - thruthy


in <ctype.h> stdblib:

isalnum, isalpha, isascii, isblank, iscntrl, isdigit, isgraph, islower, isprint, ispunct, isspace, isupper, isxdigit - character classification routines


""" Something to ponder...
The purpose of a pointer is to let you manually index into blocks or memory when an array won't do it right. In almost all other cases you actually want to use an array.
"""

type *ptr
*ptr
*(ptr + i)
&thing - address
type *ptr = &thing
ptr++

memcpy
- copies char values (btyes) from one contiguous piece of memory to another
- can copy anything as long as you know the address

value and reference semantics
- value: copies; memcpy
- reference: same thingl use pointers

pointers are just addresses in memory

array[i] == *(array+i) // a pointer to the address
array length not stored anywhere
all you have is a pointer to the start of the contiguous block of memory
and that block contains the same type of things

malloc(sizeof(Thing)) return a generic pointer to mem

'owners' of pointers

C preprocessor
--------------
- responds to # directives (used to tranform code)
- directives
    #include
        - only header files which contain declarations to definitions
        - include the header file in the one that contains the actual definitions
    #define
        - macros (only textual replacement no parsing)
    #if, #else, #elif, #endif
        - 'conditional compilation' based on some predicate
- $ cpp mapred.c | less
- used as a code generator for templated pieces

strace
------
strace -s 2000 -f ./program
strace -T ./program (timing/profiling)
lsof # to check file descriptors

check how many cores you have:
mac: sysctl hw.logicalcpu
nix: grep cores /proc/cpuinfo

dynamic mem allocation
----------------------
- malloc (general)
- obstacks (more efficient and convenient for stacklike allocation)
    - a pool of memory containing a stack of objects
- alloca (vlocks allocated dynamically, freed automatically)
    - could be difficult to debug if error occurs
    - less portable than malloc

- static, allocated once and never freed
- automatic, allocated when compund statement (e.g function) is entered and freed when exited
- dynamic, not supported by C variables
- can only refer to dynamically allocated space with a pointer
- realloc (change size of malloc'ed block)

aside:
http://www.catb.org/esr/structure-packing/
Scheme and C play well together... hmmm... juicy combo
gambit and chicken Scheme with good FFI to C
http://snow.iro.umontreal.ca/
https://github.com/alvatar/sphere-sdl2
http://blog.fourthbit.com/2013/06/07/using-match-and-comprehensions-in-scheme/
http://www.schemespheres.org/

autotools
---------
http://blog.fourthbit.com/2013/06/18/creating-an-open-source-program-in-c-with-autotools-part-1-of-2/

rand
srand
getchar


http://danluu.com/edit-binary/
------------------------------
lldb
hexfriend

Embed JS in C
-------------
http://duktape.org/index.html

Valgrind and gdb
----------------
http://billiob.net/blog//20140330_vgdb.html

a small JIT
-----------
http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html
http://blog.reverberate.org/

static analysis
---------------
http://frama-c.com/what_is.html


assert(pointer != NULL);
size_t - unsigned integer used to represent sizes of objects (of at least 16 bits) the result of a sizeof() operations is of type size_t

strdup - returns pointer to new duplicated string, memory allocated with malloc
getchar - reads next character from stdin stream, returns it as an unsigned char cast to an int or EOF
rand - generate pseudo-random bytes (openssl tool)
srand - sets argument as seed for new one - repeatable seq
time
calloc - initialises memory to 0 (malloc does not)

#ifndef - if (the following definition) not (already) defined
#define - making constants
#endif

fprintf - writes to stream (e.g. stderr)
stderr - global
errno=0 // clear errno
CPP recursively expands macros
strerror - describes the error code


data types
----------
int, default 32 bytes
double
float - smaller than double
char - 1 byte
void - no type
enum - enumerated, works like ints

type modifiers
--------------
unsigned - only > 0, so larger upper bound
signed - havles the upper bound
long - more storage
short - yeah, not long

type qualifiers
---------------
const - variable won't change after initialisation
volatile - tell the compiler not to optimise this
register - forces variable to be in the register (don't try to be smart)

type conversion
---------------
long double
double
float
int (only char and short int)
long
C promotes the smaller operand to match the larger operand
rather cast explicitly to be sure, e.g.
long + char - int * double
(double)long + (double)char - (double)int * double
AND always promote UP

type sizes
----------
stdint.h
(u)int(bits)_t, bits (8, 16, 32, 64, 128)
macros that return the max value of types:
(u)int_least(N)_t
(U)INT_LEAST(N)_MAX - max val of matching least(N) type
..._MIN
(u)int_fast(N)_t - fastest with given precision
...MAX
...MIN
(u)intptr_t - large enough to hold a pointer
...MAX
...MIN
(u)intmax_t - biggest possible on system
...MAX
...MIN
PTRDIFF_<MIN, MAX>
SIZE_MAX - max of size_t

operators
---------
binary: x+y
unary: -x
prefix: ++x
postfix: x++
ternary: x?y:z

data operators
--------------
-> struct pointer access
. struct value access
[] index
sizeof
& address
* value

logic
-----
!=, ==, <=, >=, <, >

bit
---
& bitwise and
<< shift left
>> shift right
^ xor
| or
~ compliment (flips all bits)

boolean
-------
!, &&, ||, ?:

assignment
----------
=
%= modulus assign
&= bitwise and assign
*= multiply assign
+=
-=
/=
<<= shift left assign
>>= shift right assign
^= xor assign
|= or assign

control
-------
do { ... } while(x == TRUE) - does at least once and then checks
break
continue - jumps to test
goto label:


mem
---
malloc - from the heap (what is left)
stack - stores func vars
gotchas - doing malloc on stack then pointer is on the stack - might get lost
stack overflow (use heap instead)















